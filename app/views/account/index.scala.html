@(hypergraphs: play.api.libs.json.JsValue, userHash: String)

@import play.api.libs.json.Json

<!DOCTYPE html>
<html>
  <head lang="en">
    <meta charset="UTF-8">
    <title>Graphs</title>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="@routes.Assets.at("style/dependencies/bootstrap.css")">
    <style>
      html, body {
        overflow-x:hidden;
      }

      [v-cloak] {
        display:none !important;
      }

      .x-disable-pointer-events {
        pointer-events: none;
      }

      .x-paper {
        box-shadow: rgba(255,255,255,.9) 0px 1px 0px inset,
        rgba(0,0,0,.03) 0px -1px 0px inset,
        rgba(0,0,0,.2) 0px 1px 3px;
      }

      .x-navbar, .x-flat-navbar {
        position:fixed;
        width:100%;
        top:0;
        height:70px;
        background-color:#fff;
        color:#404040;
        z-index:2;
      }

      .x-navbar {
        box-shadow:0px 1px 4px rgba(0,0,0,.34);
      }

      .x-flat-navbar {
        border-bottom: solid 1px rgba(0, 0, 0, 0.15);
      }

      ul.x-navbar-nav {
        list-style:none;
        padding:0;
        margin:0;
      }

      .x-navbar-nav > li {
        position:relative;
        display:block; /* need this to have it fit the navbar length */
        float:left; /* so the li elements displayed inline even though its a block element */
      }

      .x-navbar-nav > li > a {
        display:block; /* need this to have it fit the navbar length */
        line-height:70px;
        font-size:14px;
        font-weight:500;
        padding:0 5px 0 5px;
        height:70px;
        text-decoration: none;
        color:inherit;
        transition:all 150ms ease-in-out;
        border-bottom:solid 0 rgba(0,0,0,0);
      }

      .x-navbar-nav > li:hover > a, .x-navbar-nav > li.active > a {
        border-bottom:solid 5px #aaa;
      }

      .x-navbar-nav > li:hover > a:hover {
        color:rgba(0,0,0,.5);
      }

      .x-navbar-nav > li > a, .x-navbar-nav > li > a:hover, .x-navbar-nav > li > a:visited {
        text-decoration:none;
        color:inherit;
      }

      .x-flat-btn {
        cursor:pointer;
        text-align:center;
        border:solid 1px transparent;
        border-radius: 2px;
        display:inline-block;
        vertical-align: middle;
        padding:4px 8px;
        font-size: 14px;
      }

      .x-flat-btn:hover {
        border:solid 1px rgba(0,0,0,0.03);
        background-color:rgba(0,0,0,0.1);
      }

      .x-menu {
        background:#fff;
        position:absolute;
        white-space: nowrap;
        list-style:none;
        border:none;
        border-radius:2px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        text-align:left;
        padding:5px 0;
        margin:0;
        z-index:1000;
      }

      /* shared with before and after */
      .x-menu::before, .x-menu::after {
        content: ' ';
        height: 0;
        position: absolute;
        width: 0;
        border: 10px solid transparent; /* arrow size */
      }

      /* these arrows will point up */

      /* top-stacked, smaller arrow */
      .x-menu::before {
        border-bottom-color: #fff;  /* arrow color */

        /* positioning */
        position: absolute;
        top: -19px;
        right: 10px;
        z-index: 2;
      }

      /* arrow which acts as a background shadow */
      .x-menu::after {
        border-bottom-color: rgba(0,0,0,0.05);  /* arrow color */

        /* positioning */
        position: absolute;
        top: -20px;
        right: 10px;
        z-index: 1;
      }

      .x-menu > .x-menu-item {
        padding:5px 20px;
        display:block;
        cursor:pointer;
        width:100%;
        position:relative;
        line-height:24px;
      }

      .x-menu > .x-menu-item.selected {
        font-weight: bold;
      }

      .x-menu > .x-menu-item.selected::after {
        content: "\f00c";
        font: normal normal normal 14px/1 FontAwesome;
        font-size:inherit;
        display:inline-block;
        position:absolute;
        right:20px;
        top:10px;
      }

      .x-menu > .x-menu-item:hover {
        background-color:rgba(0,0,0,.05);
      }

      .marker-arrow {
        fill: rgba(255, 255, 255, 1);
        stroke-opacity: 0;
        stroke-width: .25em;
      }

      .link {
        opacity: .3;
        stroke: #eee;
        stroke-width: .25em;
      }

      .node-rect {
        stroke-width: 0;
        fill: #fff;
      }

      .curved-shadow {
        position:relative;
      }

      .curved-shadow::before {
        transition: opacity .3s ease;
        content: "";
        position:absolute;
        z-index: -1;
        width:96%;
        bottom: 0;
        height: 10px;
        left: 2%;
        border-radius: 100px / 5px;
        box-shadow:0 0 10px 4px rgba(0,0,0,0.25);
        opacity:0;
      }

      .curved-shadow.show::before {
        opacity:1;
      }

      .left-panel {
        padding:0 20px;
        position:fixed;
        top:80px;
        left:0;
        width:260px;
      }

      .right-panel {
        padding:0 20px;
        position:fixed;
        top:80px;
        right:0;
      }

      .main-panel {
        margin-left:250px;
        padding-left:10px;
        overflow:hidden;
      }

      .toolbar-dropdown {
        width:180px;
        right:0px;
        top:40px;
      }

      .toolbar-buttons > * {
        display:inline-block;
        position:relative;
      }

      .toolbar-buttons .x-flat-btn {
        line-height:20px;
        font-size: 17px;
        width:40px;
      }

      .thumbnails-list {
        padding-top:80px;
      }

      .thumbnails-list > a {
        margin-bottom:10px;
        display:inline-block;
        text-decoration: none;
        color:inherit;
      }

      .thumbnails-list > a:hover, .thumbnails-list > a:visited {
        color:inherit;
        text-decoration: none;
      }

      .graph-thumbnail {
        cursor:pointer;
        overflow:hidden;
        border-radius:2px;
        background-color:#fff;
        display:inline-block;
        box-shadow: 0px 1px 8px rgba(0, 0, 0, .2),
                    0px 0px 2px rgba(0, 0, 0, .2),
                    inset 0px 1px 0px rgba(255, 255, 255, .25),
                    inset 0px -1px 0px rgba(0, 0, 0, .15);
      }

      .graph-thumbnail > svg {
        background-color:#e74c3c;
        display:block;  /* SVG element default to display:inline; which causes weird padding/margin issues */
        width:300px;
        height:150px;
      }

      .graph-thumbnail > .caption {
        position:relative;
        padding:5px 10px;
      }

      .graph-thumbnail > .caption > .fa {
        position:absolute;
        right:10px;
        top:17px;
      }

      .nav > .x-navbar-nav {
        margin-left:20px;
      }

      .nav > img {
        position:absolute;
        bottom:10px;
        right:20px;
        border-radius:2px;
      }

      .sub-nav {
        top:65px;
        background: #fff;
      }
    </style>
  </head>
  <body>
    <div id="graphThumbnailsList">
      <div class="x-flat-navbar nav">
        <ul class="x-navbar-nav">
          <li class="active">
            <a href="#">Graphs</a>
          </li>
          <li>
            <a href="#">Profile</a>
          </li>
        </ul>
        <img src="https://secure.gravatar.com/avatar/@userHash?s=100" width="50" height="50" />
      </div>

      <div class="left-panel">
        <button type="button" class="btn btn-default btn-lg btn-block">New Graph</button>
      </div>

      <div class="right-panel">
        <div class="toolbar-buttons">
          <span>
            <i class="x-flat-btn fa fa-list"></i>
          </span>
          <span>
            <i class="x-flat-btn fa fa-sort" v-on="click:toggleSortMenu"></i>
            <ul class="x-menu toolbar-dropdown" v-class="hidden:!sortMenu" v-cloak>
              <li class="x-menu-item" v-class="selected:sortedBy=='created'" v-on="click:sortedBy='created'">
                Date created
              </li>
              <li class="x-menu-item" v-class="selected:sortedBy=='modified'" v-on="click:sortedBy='modified'">
                Date modified
              </li>
              <li class="x-menu-item" v-class="selected:sortedBy=='title'" v-on="click:sortedBy='title'">
                Title
              </li>
            </ul>
          </span>
        </div>
      </div>

      <div class="main-panel">
        <div class="thumbnails-list center-block">
          <x-graph-thumbnail v-repeat="sortedHypergraphs"></x-graph-thumbnail>
        </div>
      </div>
    </div>

    <template id="link.thumbnail">
      <g>
        <line
          class="link"
          v-attr="x1:sourceX, y1:sourceY, x2:targetX, y2:targetY"
        ></line>
      </g>
    </template>

    <template id="node.thumbnail">
      <g
        class="node enable-pointer-events"
        v-attr="id: id, transform: nodeTranslate"
      >
        <rect
          class="node-rect"
          rx="2"
          ry="2"
          v-el="nodeRect"
          v-attr="width:width, height:height, transform:rectTranslate"
        ></rect>
        <text
          class="node-name x-disable-pointer-events"
          text-anchor="middle"
          v-el="nodeName"
        >
          {{data.name}}
        </text>
      </g>
    </template>

    <template id="graph.thumbnail">
      <a href="/graph/{{graph.id}}">
        <div class="graph-thumbnail">
          <svg v-attr="viewBox:viewBox" v-el="svg" style="background-color:#{{graph.data.background}};">
            <defs>
              <marker
                  id="def-marker-arrow"
                  markerWidth="2"
                  markerHeight="2"
                  refx="1.6"
                  refy="1"
                  orient="auto"
              >
                <path d="M0,0 L0,2 L2,1 L0,0" class="marker-arrow"></path>
              </marker>
              <marker
                  id="def-marker-ghost-arrow"
                  markerWidth="2"
                  markerHeight="2"
                  refx="0"
                  refy="1"
                  orient="auto"
              >
                <path d="M0,0 L0,2 L2,1 L0,0" class="marker-arrow"></path>
              </marker>
            </defs>

            <g class="x-disable-pointer-events" v-el="nodesAndLinksGroup">
              <!-- Nodes -->
              <x-node-thumbnail v-repeat="nodes"></x-node-thumbnail>

              <!-- Links -->
              <x-link-thumbnail v-repeat="links"></x-link-thumbnail>
            </g>
          </svg>
          <div class="caption">
            <h6>{{graph.data.name}}</h6>
            <i class="fa fa-ellipsis-v"></i>
          </div>
        </div>
      </a>
    </template>
  </body>

  <script src="@routes.Assets.at("js/dependencies/require.js")"></script>

  <script>

    require.config({
      baseUrl: '/assets/js',
      paths: {
        d3: 'dependencies/d3',
        jquery: 'dependencies/jquery-2.1.1',
        lodash: 'dependencies/lodash',
        mousetrap: 'dependencies/mousetrap',
        q: 'dependencies/q',
        snap: 'dependencies/snap.svg',
        vue: 'dependencies/vue',
        bootstrap: 'dependencies/bootstrap',
        page: 'dependencies/page'
      }
    });

    var userGraphs = @Html(Json.stringify(hypergraphs)); //bootstrap json data into view template
  </script>

  <script>
    require([
        'lodash',
        'jquery',
        'vue',
        'models'
    ],
    function(_, $, Vue, models){

      var Node = models.Node;
      var Link = models.Link;

      var deferredHypergraphsData = _.map(userGraphs, function(hg) {
        return $
            .when(Node.fetchAll(hg.id), Link.fetchAll(hg.id))
            .then(function(nodes, links) {
              nodes.forEach(function (n) {
                links.forEach(function (l) {
                  if (l.sourceId == n.id) l.source = n;
                  if (l.targetId == n.id) l.target = n;
                });
              });

              return {
                graph: hg,
                nodes: nodes,
                links: links
              };
            });
      });


      function liangBarsky(edgeLeft, edgeRight, edgeBottom, edgeTop,
                           x0src, y0src, x1src, y1src) {
        var t0 = 0.0, t1 = 1.0;
        var xdelta = x1src-x0src;
        var ydelta = y1src-y0src;
        var p,q,r;

        for(var edge=0; edge<4; edge++) {   // Traverse through left, right, bottom, top edges.
          if (edge === 0) {
            p = -xdelta;
            q = -(edgeLeft - x0src);
          }
          else if (edge === 1) {
            p = xdelta;
            q =  (edgeRight - x0src);
          }
          else if (edge === 2) {
            p = -ydelta;
            q = -(edgeBottom - y0src);
          }
          else if (edge === 3) {
            p = ydelta;
            q = (edgeTop - y0src);
          }

          r = q/p;

          if (p === 0 && q < 0) {     // Don't draw line at all. (parallel line outside)
            return false;
          }

          if (p < 0) {
            if (r > t1) return false; // Don't draw line at all.
            else if (r > t0) t0=r;    // Line is clipped!
          }
          else if (p > 0) {
            if (r < t0) return false; // Don't draw line at all.
            else if (r<t1) t1=r;      // Line is clipped!
          }
        }

        return {
          x0Clip: x0src + (t0 * xdelta), // x0clip
          y0Clip: y0src + (t0 * ydelta), // y0clip
          x1Clip: x0src + (t1 * xdelta), // x1clip
          y1Clip: y0src + (t1 * ydelta)  // y1clip
        };
      }

      function viewBoundsToFitAllNodes(nodes) {
        var bounds = {
          xMin: Number.POSITIVE_INFINITY,
          xMax: Number.NEGATIVE_INFINITY,
          yMin: Number.POSITIVE_INFINITY,
          yMax: Number.NEGATIVE_INFINITY
        };

        bounds = _.reduce(nodes, function(bounds, n) {
          if (n.x < bounds.xMin) bounds.xMin = n.x;
          if (n.x > bounds.xMax) bounds.xMax = n.x;
          if (n.y < bounds.yMin) bounds.yMin = n.y;
          if (n.y > bounds.yMax) bounds.yMax = n.y;

          return bounds;
        }, bounds);

        return bounds;
      }

      var LinkThumbnailComponent = Vue.extend({

        template: document.getElementById('link.thumbnail').innerHTML,

        replace: true,

        data: function() {
          return {
            targetClipX: 0,
            targetClipY: 0
          };
        },

        computed: {
          sourceX: function() {
            return this.source.x;
          },
          sourceY: function() {
            return this.source.y;
          },
          targetX: function() {
            return this.target.x;
          },
          targetY: function() {
            return this.target.y;
          }
        },

        methods: {

          liangBarskyTest : function ( ) {
            //TODO: bug with translate transforms

            var source = this.source ;
            var target = this.target ;

            var clippings = liangBarsky(
              target.leftEdge,
              target.rightEdge,
              target.topEdge,
              target.bottomEdge,
              source.x,
              source.y,
              target.x,
              target.y
            );

            this.targetClipX = clippings.x0Clip;
            this.targetClipY = clippings.y0Clip;
          }

        }

      });

      Vue.component('x-link-thumbnail', LinkThumbnailComponent);

      var NodeThumbnailComponent = Vue.extend({

        template: document.getElementById('node.thumbnail').innerHTML,

        replace: true,

        data: function() {
          return {
            x : 0,
            y : 0,
            leftEdge : 0,
            rightEdge : 0,
            bottomEdge : 0,
            topEdge : 0,
            nameX : 0,
            nameY : 0,
            width : 0,
            height : 0,
            data: {
              name: ''
            }
          };
        },

        computed: {

          nodeTranslate: function() {
            return 'translate(' + this.x + ',' + this.y + ')';
          },

          nameTranslate: function() {
            return 'translate(' + this.nameX + ',' + this.nameY + ')';
          },

          rectTranslate: function() {
            return 'translate(' + (-this.width/2) + ',' + (-(this.height + 12)/2) + ')';
          }

        },

        events: {

          'hook:ready': function() {
            this.updateDimensionsOfNodeRect();
            this.calculateRectBoundingEdges();
          }

        },

        methods: {

          calculateRectBoundingEdges: function() {
            // we get the transform to nodesAndLinksGroup element
            // because, in calculating the bounding edges, we only
            // want the transforms applied to the node element itself
            // while disregarding the transforms to nodesAndLinksGroup
            var ttm = this.$$.nodeRect.getTransformToElement(this.$parent.$$.nodesAndLinksGroup);
            var bBox = this.$$.nodeRect.getBBox();
            var point = this.$parent.$$.svg.createSVGPoint();
            var dimensions = this.$parent.$$.svg.createSVGPoint();

            point.x = bBox.x;
            point.y = bBox.y;

            point = point.matrixTransform(ttm);

            ttm.e = ttm.f = 0; // next we multiply bBox.width/height as vectors

            dimensions.x = bBox.width;
            dimensions.y = bBox.height;

            dimensions = dimensions.matrixTransform(ttm);

            this.leftEdge = point.x;
            this.rightEdge = point.x + dimensions.x;
            this.topEdge = point.y;
            this.bottomEdge = point.y + dimensions.y;
          },

          updateDimensionsOfNodeRect: function() {
            var bBox = this.$$.nodeName.getBBox();

            this.width = bBox.width + 24;
            this.height = bBox.height + 12;
          }

        }

      });

      Vue.component('x-node-thumbnail', NodeThumbnailComponent);

      var GraphThumbnailComponent = Vue.extend({

        template: '#graph.thumbnail',

        replace: true,

        data: function() {
          return {
            links: [],
            nodes: [],
            bounds: {
              xMin: 0,
              xMax: 1200,
              yMin: 0,
              yMax: 675
            }
          };
        },

        computed: {

          viewBox: function() {
            var b = this.bounds;
            return b.xMin + ' ' + b.yMin + ' ' + (b.xMax - b.xMin) + ' ' + (b.yMax - b.yMin);
          }

        },

        events: {

          'hook:created': function() {
            this.bounds = viewBoundsToFitAllNodes(this.nodes);
          }

        }

      });

      Vue.component('x-graph-thumbnail', GraphThumbnailComponent);

      var letters = [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N' ];
      var colors = [ '2e6d8c', '8c261b', 'e74c3c', '4694c6', 'dd6580', '626264' ];
      var counter = 0;

      var GraphThumbnailsListComponent = Vue.extend({

        data: function() {
          return {
            pageYOffset: 0,
            sortedBy: 'modified',
            sortMenu: false,
            hypergraphs: [ ]
          };
        },

        computed: {

          sortedHypergraphs: function() {
            var hypergraphs = this.hypergraphs;

            switch(this.sortedBy) {
            case 'title':
              hypergraphs = _.sortBy(hypergraphs, function(hypergraph) {
                return hypergraph.graph.data.name;
              });
              break;
            case 'modified':
              hypergraphs = _.sortBy(hypergraphs, function(hypergraph) {
                return hypergraph.graph.updatedAt;
              });
              break;
            default:
              hypergraphs = _.sortBy(hypergraphs, function(hypergraph) {
                return hypergraph.graph.createdAt;
              });
              break;
            }

            return hypergraphs;
          }

        },

        events: {

          'hook:created': function() {
            var self = this;

            $.when.apply($, deferredHypergraphsData).then(function() {
              var hypergraphs = Array.prototype.slice.call(arguments);

              _.forEach(_.range(18), function() {
                var hypergraph = _.cloneDeep(hypergraphs[0]);
                hypergraph.graph.data.background = colors[counter % colors.length];
                hypergraph.graph.data.name = letters[counter % letters.length];
                hypergraph.graph.createdAt += counter + Math.floor(Math.random()*100);
                hypergraph.graph.updatedAt -= counter + Math.floor(Math.random()*100);
                counter++;
                self.hypergraphs.push(hypergraph);
              });
            });

            var self = this;
            window.addEventListener('scroll', function() {
              self.pageYOffset = window.pageYOffset;
            });
          }

        },

        methods: {

          toggleSortMenu: function(e) {
            if (this.sortMenu)
              return;

            e.stopPropagation();

            this.sortMenu = true;

            var self = this;

            var closeMenu = function() {
              self.sortMenu = false;
              window.removeEventListener('click', closeMenu);
            };

            window.addEventListener('click', closeMenu);
          }

        }

      });

      // init code
      var graphThumbnailsList = new GraphThumbnailsListComponent().$mount('#graphThumbnailsList')
    });
  </script>
</html>